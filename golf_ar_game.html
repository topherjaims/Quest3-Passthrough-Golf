<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>WebXR AR Golf Demo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
      /* Basic styling for full‑screen canvas and overlay text */
      body { margin: 0; overflow: hidden; background: #000; color: #fff; }
      #overlay {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 10;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        font: 15px system-ui;
        background: rgba(0,0,0,0.4);
        padding: 8px 12px;
        border-radius: 8px;
      }
      #overlay button {
        cursor: pointer;
        padding: 6px 10px;
        border-radius: 6px;
        border: none;
        background: rgba(255,255,255,0.2);
        color: #fff;
      }
      #overlay button:disabled { opacity: 0.5; cursor: default; }
      #overlay label { display: flex; align-items: center; gap: 4px; }
    </style>
    <!-- Import map for Three.js and its examples -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
  </head>
  <body>
    <!-- Overlay UI for game instructions and controls -->
    <div id="overlay">
      <span id="msg">Point at floor and tap trigger to place screen.</span>
      <button id="resetBtn">Reset Ball</button>
      <label><input type="checkbox" id="lefty"> Left‑handed</label>
      <span id="status">Loading…</span>
    </div>

    <script type="module">
      import * as THREE from 'three';
      import { ARButton } from 'three/addons/webxr/ARButton.js';

      let scene, camera, renderer;
      let controller1, controller2;
      let reticle;
      let hitTestSource = null;
      let hitTestSourceRequested = false;
      let screenMesh;
      let screenPlaced = false;
      let texture;
      // 2D canvas for drawing the driving range and ball
      const canvas2d = document.createElement('canvas');
      canvas2d.width = 1280;
      canvas2d.height = 720;
      const ctx = canvas2d.getContext('2d');

      // Ball physics variables
      let ball = { x: 120, y: 680, vx: 0, vy: 0, flying: false };
      const pxPerMeterX = 240;
      const pxPerMeterY = 240;
      const gravity = 9.81;
      const dt = 1 / 60;

      // Swing variables
      let lastPos = null;
      let lastTime = 0;
      let held = false;
      let peak = 0;
      let lastYaw = 0;
      let leftHanded = false;

      // DOM elements
      const msgSpan = document.getElementById('msg');
      const resetBtn = document.getElementById('resetBtn');
      const leftyChk = document.getElementById('lefty');
      const statusSpan = document.getElementById('status');

      leftyChk.addEventListener('change', () => {
        leftHanded = leftyChk.checked;
      });
      resetBtn.addEventListener('click', resetBall);

      // Draw driving range background stripes and yard markers
      function drawBackground() {
        ctx.fillStyle = '#0b2a';
        ctx.fillRect(0, 0, canvas2d.width, canvas2d.height);
        ctx.strokeStyle = '#1d5';
        ctx.lineWidth = 2;
        for (let y = 640; y > 120; y -= 44) {
          ctx.beginPath();
          ctx.moveTo(80, y);
          ctx.lineTo(canvas2d.width - 80, y);
          ctx.stroke();
        }
        ctx.fillStyle = '#9f9';
        ctx.font = '20px system-ui';
        for (let i = 50; i <= 300; i += 50) {
          const y = 640 - i * 1.6;
          if (y > 120) ctx.fillText(i + 'y', 20, y);
        }
        ctx.strokeStyle = '#6fa';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(canvas2d.width / 2, 700);
        ctx.lineTo(canvas2d.width / 2, 120);
        ctx.stroke();
      }

      function drawBall() {
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, 7, 0, Math.PI * 2);
        ctx.fill();
      }

      function resetBall() {
        ball = { x: 120, y: 680, vx: 0, vy: 0, flying: false };
      }

      function launchBall(speedMps, loftDeg = 12, sideDeg = 0) {
        const loft = THREE.MathUtils.degToRad(loftDeg);
        const side = THREE.MathUtils.degToRad(sideDeg);
        const horiz = speedMps * Math.cos(loft);
        ball.vx = (horiz * Math.cos(side)) * (pxPerMeterX * dt);
        ball.vy = -(speedMps * Math.sin(loft)) * (pxPerMeterY * dt);
        ball.flying = true;
      }

      function stepBall() {
        if (!ball.flying) return;
        ball.x += ball.vx;
        ball.y += ball.vy;
        ball.vy += (gravity * pxPerMeterY * dt * dt);
        if (ball.y > 680) {
          ball.y = 680;
          ball.flying = false;
        }
      }

      // Update the 2D canvas and texture
      function updateCanvasTexture() {
        drawBackground();
        stepBall();
        drawBall();
        if (texture) texture.needsUpdate = true;
      }

      // Determine active controller (based on handedness)
      function getActiveController() {
        if (!renderer.xr.isPresenting) return null;
        const session = renderer.xr.getSession();
        for (const src of session.inputSources) {
          if (!src.gripSpace) continue;
          if (leftHanded && src.handedness === 'left') return src;
          if (!leftHanded && src.handedness === 'right') return src;
        }
        // Fallback: return any available controller
        return session.inputSources.find(s => s.gripSpace) || null;
      }

      function pollController(frame) {
        const src = getActiveController();
        if (!src || !src.gripSpace) return;
        const refSpace = renderer.xr.getReferenceSpace();
        const pose = frame.getPose(src.gripSpace, refSpace);
        if (!pose) return;
        const t = frame.predictedDisplayTime !== undefined ? frame.predictedDisplayTime : performance.now() / 1000;
        if (lastPos) {
          const dtSec = Math.max(1 / 120, t - lastTime);
          const p = pose.transform.position;
          const dx = p.x - lastPos.x;
          const dy = p.y - lastPos.y;
          const dz = p.z - lastPos.z;
          const mps = Math.hypot(dx, dy, dz) / dtSec;
          if (held) peak = Math.max(peak, mps);
          const q = pose.transform.orientation;
          const yaw = Math.atan2(2 * (q.w * q.y + q.x * q.z), 1 - 2 * (q.y * q.y + q.z * q.z)) * 180 / Math.PI;
          lastYaw = yaw;
        }
        lastPos = pose.transform.position;
        lastTime = t;
      }

      // Event handlers for controller interactions
      function onSelect(event) {
        if (!screenPlaced && reticle.visible) {
          // Place the screen at the reticle location and orient it to face the user
          const retMat = new THREE.Matrix4();
          retMat.fromArray(reticle.matrix.elements);
          const position = new THREE.Vector3();
          const quaternion = new THREE.Quaternion();
          const scale = new THREE.Vector3();
          retMat.decompose(position, quaternion, scale);
          // Position the screen at the hit test location
          screenMesh.position.copy(position);
          screenMesh.quaternion.copy(quaternion);
          // Rotate screen to face user; reticle points downwards, so rotate around X to make plane upright
          screenMesh.rotateX(-Math.PI / 2);
          screenMesh.visible = true;
          screenPlaced = true;
          msgSpan.textContent = 'Hold trigger & swing. Release to hit.';
        }
      }

      function onSelectStart(event) {
        if (!screenPlaced) return;
        held = true;
        peak = 0;
      }

      function onSelectEnd(event) {
        if (!screenPlaced) return;
        if (held) {
          held = false;
          const speed = Math.min(90, peak * 6 + 10);
          const side = Math.max(-15, Math.min(15, lastYaw * 0.2));
          resetBall();
          launchBall(speed, 12, side);
        }
      }

      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        scene.add(new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3));
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        // AR button with hit-test feature
        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

        // Reticle for placing the screen
        reticle = new THREE.Mesh(
          new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
          new THREE.MeshBasicMaterial({ color: 0x00ffff })
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add(reticle);

        // Create screen plane but do not position yet
        const planeGeometry = new THREE.PlaneGeometry(5, 2.8125);
        texture = new THREE.CanvasTexture(canvas2d);
        const planeMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
        screenMesh = new THREE.Mesh(planeGeometry, planeMaterial);
        screenMesh.visible = false;
        scene.add(screenMesh);

        // Controllers
        controller1 = renderer.xr.getController(0);
        controller1.addEventListener('select', onSelect);
        controller1.addEventListener('selectstart', onSelectStart);
        controller1.addEventListener('selectend', onSelectEnd);
        scene.add(controller1);
        controller2 = renderer.xr.getController(1);
        controller2.addEventListener('select', onSelect);
        controller2.addEventListener('selectstart', onSelectStart);
        controller2.addEventListener('selectend', onSelectEnd);
        scene.add(controller2);

        window.addEventListener('resize', onWindowResize);
        renderer.setAnimationLoop(animate);
        statusSpan.textContent = 'Ready – load the page on Quest 3 and tap Enter AR.';
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate(timestamp, frame) {
        updateCanvasTexture();
        if (frame) {
          const session = renderer.xr.getSession();
          // Request hit test source once per session
          if (!hitTestSourceRequested) {
            session.requestReferenceSpace('viewer').then((refSpace) => {
              session.requestHitTestSource({ space: refSpace }).then((source) => {
                hitTestSource = source;
              });
            });
            session.addEventListener('end', () => {
              hitTestSourceRequested = false;
              hitTestSource = null;
              screenPlaced = false;
              screenMesh.visible = false;
              reticle.visible = false;
              msgSpan.textContent = 'Point at floor and tap trigger to place screen.';
            });
            hitTestSourceRequested = true;
          }
          // Update reticle if screen not placed
          if (!screenPlaced && hitTestSource) {
            const viewerSpace = renderer.xr.getReferenceSpace();
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const pose = hit.getPose(viewerSpace);
              if (pose) {
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
              }
            } else {
              reticle.visible = false;
            }
          }
          // Poll controller motion and handle swing during gameplay
          pollController(frame);
        }
        renderer.render(scene, camera);
      }

      init();
    </script>
  </body>
</html>